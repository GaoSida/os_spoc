# Stride处理机调度算法 实验报告
计35  高思达  2013011413

#### 1、实现要点说明
* 自定义了任务类Job。其中主要保存的信息是任务的pid，优先级，需要执行的时间，当前的剩余执行时间（即进度）。为了支持Stride算法，需要保存Stride。同时，为了方便统计，同时保存进程的响应时间和等待时间。
* 注意，由于进程的优先级是可以动态变化的，因此`Pass = BigStride / Priority`并不能作为任务的属性，而需要在调度时现计算。
* 算法的主要流程是：每次上一进程的时间片结束后，选择所有就绪进程中Stride最小的进程调度。对于被调度的进程，更新其Stride的值为`Old_Stride + Pass`，其中`Pass = BigStride / Priority`。
* 相应时间的计算方法为：如果调度时发现该进程的剩余时间还是总的执行时间，则表明这是第一次调度。于是当前进程的等待时间就是响应时间。
* 对于没有被调度的进程，把当前时间片累加到他们的等待时间中。
* 轮转时间 = 执行时间 + 等待时间。 

#### 2、结果分析
在代码中给出的简单测试用例中可以看出，优先级更高的进程会被优先调度，会有更短的等待时间（相对执行时间而言的比例更短）。而优先级较低的进程，即便本身所需的执行时间较短，最终也会因为等待高优先级的进程先执行，而较晚做完。这是符合我们对于优先级的要求的，可以看到Stride算法的调度效果。

#### 3、算法实现的不足
当前并没有考虑Stride溢出时的比较大小方式。这一完善将留到Lab6中在实际的ucore代码中完成。